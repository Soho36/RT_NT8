import pandas as pd
# from datetime import datetime, timedelta

# log_file_reading_interval = 1       # File reading interval (sec)

# +------------------------------------------------------------------+
# FILE TRANSMIT PATHS
# +------------------------------------------------------------------+

mt5_account_number = 828    # LAST 3 DIGITS OF MT5 ACCOUNT. MUST BE CHANGED BEFORE BUILDING EXE

# MT5 directory with OHLC log file (logging on active timeframe):

# ------------------------
# LIIKURI PATHS # HASH FOLDER MUST BE CHANGED BEFORE EXE BUILD
# mt5_logging_file_path = (
#     f'C:\\Users\\Liikurserv\\AppData\\Roaming\\MetaQuotes\\Terminal\\09FF355D73768D9CE6BDD4EE575EAB09\\MQL5\\Files\\'
#     f'OHLCVData_{mt5_account_number}.csv'
# )

# OHLC saved by NT8
nt8_logging_file_path = f'C:\\Users\\Liikurserv\\PycharmProjects\\RT_Ninja\\OHLCVData_1.csv'

# File with signal generated by Python script
nt8_buy_sell_signals_for_path = (
     f'C:\\Users\\Liikurserv\\PycharmProjects\\RT_Ninja\\trade_signal.txt'
     )

# Levels PATH for NinjaTrader:
levels_path = (
    f'C:\\Users\\Liikurserv\\PycharmProjects\\RT_Ninja\\hardcoded_sr_levels.csv'
)

list_of_orders_path = 'C:\\Users\\Liikurserv\\PycharmProjects\\RT_Ninja\\list_of_orders.csv'

position_state_path = 'C:\\Users\\Liikurserv\\PycharmProjects\\RT_Ninja\\position_state.txt'

current_order_direction_path = 'C:\\Users\\Liikurserv\\PycharmProjects\\RT_Ninja\\current_order_direction.txt'


def leave_only_last_line():     # Clear file before starting the script
    with open(nt8_logging_file_path, 'r', encoding='utf-8') as file:
        lines = file.readlines()
        # Check if there's at least one line to keep
        if lines:
            with open(nt8_logging_file_path, 'w', encoding='utf-8') as file:
                file.write(lines[-1])  # Write only last several lines back to file
        else:
            print('Reading OHLC. File is empty...')


def get_dataframe_from_file(max_time_waiting_for_entry):

    log_df = pd.read_csv(
        nt8_logging_file_path,
        sep=';',
        encoding='utf-8',
        engine='python'
    )
    new_column_names = ['Ticker', 'Timeframe', 'Date', 'Time', 'Open', 'High', 'Low', 'Close', 'Volume']
    log_df.columns = new_column_names
    log_df['Datetime'] = pd.to_datetime(log_df['Date'] + ' ' + log_df['Time'], format='ISO8601')
    log_df.set_index('Datetime', inplace=True)
    dataframe_from_log = log_df.loc[:, ['Ticker', 'Date', 'Time', 'Open', 'High', 'Low', 'Close']]
    datetime_index = log_df.index
    last_date = str(datetime_index[-1])     # Get datetime of the first row of dataframe to pass along with levels

    return dataframe_from_log, last_date


def get_levels_from_file(last_datetime_of_df):
    updated_lines = []
    levels = []

    with open(levels_path, 'r', encoding='utf-8') as file:
        for line in file:
            parts = line.strip().split(',')

            if len(parts) == 2:
                # Properly formatted line
                timestamp = parts[0].strip()
                level = float(parts[1].strip())
            # else:
            #     # Line with only a level; add current timestamp
            #     current_time = datetime.now()
            #
            #     # if current_time.second > 0:
            #     current_time -= timedelta(hours=2)
            #
            #     current_time = current_time.replace(second=0, microsecond=0)
            #
            #     timestamp = current_time.strftime('%Y-%m-%d %H:%M:%S')
            #     level = float(parts[0].strip())
            else:
                timestamp = last_datetime_of_df
                level = float(parts[0].strip())

            # Add the formatted line to the update list
            updated_lines.append(f"{timestamp}, {level}\n")
            levels.append((timestamp, level))

    # Rewrite the file with only properly formatted lines
    with open(levels_path, 'w', encoding='utf-8') as file:
        file.writelines(updated_lines)

    return levels


#   Remove level which has reached time threshold from file
def remove_expired_levels(level_lifetime_minutes, dataframe_from_log, interacted_levels):

    current_time = dataframe_from_log.index[-1]  # Timestamp of the last line of dataframe
    updated_levels = []
    print('\nLevels management:')
    print('interacted_levels', interacted_levels)
    print(f'level_lifetime_minutes: {level_lifetime_minutes} minutes\n')
    with open(levels_path, 'r', encoding='utf-8') as file:
        for line in file:
            timestamp_str, file_level = line.strip().split(',')  # Get timestamp and level from file
            file_level = float(file_level.strip())

            # Flag to check if the level is still valid
            level_still_valid = False

            for interaction_time, level in interacted_levels:
                if level == file_level:  # Match the file level with interacted level
                    # Calculate the time difference
                    time_diff = (current_time - pd.to_datetime(interaction_time)).total_seconds() / 60  # Convert to minutes
                    print(f"Level {level}: Time difference {time_diff:.2f} minutes")

                    if time_diff < level_lifetime_minutes:
                        level_still_valid = True  # Mark as valid
                        break  # No need to check other interactions for the same level

                    # Add the level back if it’s still valid or hasn’t been interacted with
            if level_still_valid or all(file_level != lvl for _, lvl in interacted_levels):
                updated_levels.append(line)
            else:
                print(f"Removing expired level: {timestamp_str}, {file_level}")

    # Write the remaining levels back to the file
    with open(levels_path, 'w', encoding='utf-8') as file:
        file.writelines(updated_levels)


# Tracks if there is an open position
def get_position_state():
    with open(position_state_path, 'r', encoding='utf-8') as file:
        state = file.read()
        return state


def get_current_pending_order_direction():
    with open(current_order_direction_path, 'r', encoding='utf-8') as file:
        current_pending_order = file.read().strip()
        return current_pending_order


def save_order_parameters_to_file(line_order_parameters):   # Called from orders_sender.py
    with open(nt8_buy_sell_signals_for_path, 'w', encoding='utf-8') as file:
        file.writelines(line_order_parameters)
        print('NEW ORDER IS SUCCESSFULLY SAVED TO FILE')


# Create orders list file to track orders
def save_list_of_orders_to_file(line_order_parameters_to_order_list):
    with open(list_of_orders_path, 'w', encoding='utf-8') as file:
        file.writelines(line_order_parameters_to_order_list)


def get_last_order_time_from_file():
    with open(list_of_orders_path, 'r', encoding='utf-8') as file:
        last_order_timestamp = pd.to_datetime(file.read())
        if pd.isna(last_order_timestamp):
            last_order_timestamp = pd.to_datetime('2024-01-01 00:00:00')  # Default value while the file is empty

        return last_order_timestamp
